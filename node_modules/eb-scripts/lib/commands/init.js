"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@oclif/command");
const child_process_1 = require("child_process");
const fs = require("fs");
const DEFAULT_PROJECT_NAME = "react";
// Grab the path of the user's project
const pathWhereScriptIsRunning = process.cwd();
exports.scriptsByProject = {
    react: {
        "g:component": "eb-scripts generate react-component -p src/components -n"
    },
    "react-typescript": {
        "g:component": "eb-scripts generate react-typescript-component -p src/components -n"
    },
    "react-native-typescript": {
        "g:component": "eb-scripts generate react-native-typescript-component -p src/components -n",
        "g:screen": "eb-scripts generate react-native-typescript-screen -p src/screens -n",
        "g:e2e": "eb-scripts generate react-native-e2e -p e2e -n",
        "g:util": "eb-scripts generate util-typescript -p src/utils -n"
    }
};
// Use the keys from scriptsByProject as valid projec types
const validProjectTypes = Object.keys(exports.scriptsByProject);
class Init extends command_1.Command {
    async run() {
        const { args } = this.parse(Init);
        const project = args.project || DEFAULT_PROJECT_NAME;
        // Grab their package Json
        const packageJsonLocation = `${pathWhereScriptIsRunning}/package.json`;
        const packageJson = require(packageJsonLocation);
        const theirScripts = packageJson.scripts || {};
        const validProjectTypes = Object.keys(exports.scriptsByProject);
        const isValidProject = validProjectTypes.includes(project);
        // Check if project is valid
        if (!isValidProject) {
            console.error(`
        Error: invalid project type.
        Please use one of the following:
        ${validProjectTypes}
        `);
            return;
        }
        this.log(`Initializing new ${project} project`);
        // Otherwise, it is valid, so we tell TypeScript to assert it as a ProjectType
        const projectScripts = exports.scriptsByProject[project];
        // Combine their scripts with our scripts
        const updatedScripts = Object.assign(Object.assign({}, projectScripts), theirScripts);
        packageJson.scripts = updatedScripts;
        this.log(`Writing to package.json scripts...`);
        fs.writeFileSync(packageJsonLocation, JSON.stringify(packageJson, null, 2));
        // *******************
        // Install `eb-scripts`
        // We do this so that the scripts we added to their package.json
        // work correctly.
        // *******************
        this.log(`Installing eb-scripts as a devDependency`);
        const yarnLockPath = pathWhereScriptIsRunning + "/yarn.lock";
        const hasYarnLock = fs.existsSync(yarnLockPath);
        // Check if they're using yarn
        if (hasYarnLock) {
            child_process_1.execSync("yarn add --dev eb-scripts", { cwd: pathWhereScriptIsRunning });
        }
        else {
            child_process_1.execSync("npm add --save-dev eb-scripts", {
                cwd: pathWhereScriptIsRunning
            });
        }
        this.log(`Done initializing.`);
    }
}
exports.default = Init;
Init.description = "initializes project by installing `eb-scripts` and adding scripts to `package.json`";
Init.examples = [`$ npx eb-scripts init react`];
Init.flags = {
    help: command_1.flags.help({ char: "h" })
};
Init.args = [
    {
        name: "project",
        required: true,
        description: `The language or framework of the project.\nValid options: ${validProjectTypes}`,
        options: validProjectTypes
    }
];
