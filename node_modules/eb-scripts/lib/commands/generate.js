"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@oclif/command");
const child_process_1 = require("child_process");
const utils_1 = require("../utils/");
exports.DEFAULT_COMPONENT_NAME = "MyNewComponent";
const DEFAULT_TEMPLATE_NAME = "react-component";
const DEFAULT_COMPONENT_PATH = "src/components";
const DEFAULT_SCREEN_PATH = "src/screens";
const DEFAULT_E2E_PATH = "e2e";
const DEFAULT_UTILS_PATH = "src/utils";
// "as const" returns a readonly union type of strings from the array
const VALID_TEMPLATE_TYPES = [
    "react-component",
    "react-typescript-component",
    "react-native-typescript-component",
    "react-native-typescript-screen",
    "react-native-e2e",
    "util-typescript"
];
// We spread the Valid Template Types into a new array
// so that it is "mutable" and can be used with flags.template.options
const templateOptions = [...VALID_TEMPLATE_TYPES];
class Generate extends command_1.Command {
    async run() {
        const { flags, args } = this.parse(Generate);
        // Assert flags.template as a TemplateType, so TS knows it should be a TemplateType
        const template = args.templateName || DEFAULT_TEMPLATE_NAME;
        const name = flags.name;
        let DEFAULT_PATH = "";
        // If the template is a component
        if ([
            "react-component",
            "react-typescript-component",
            "react-native-typescript-component"
        ].includes(template)) {
            // Use the default component path
            DEFAULT_PATH = DEFAULT_COMPONENT_PATH;
        }
        // If the template is a screen
        if (template === "react-native-typescript-screen") {
            // Use the screen path
            DEFAULT_PATH = DEFAULT_SCREEN_PATH;
        }
        if (template === "react-native-e2e") {
            DEFAULT_PATH = DEFAULT_E2E_PATH;
        }
        if (template === "util-typescript") {
            DEFAULT_PATH = DEFAULT_UTILS_PATH;
        }
        // The path where the files will go when generated
        let path = flags.path || DEFAULT_PATH;
        const templateLocation = utils_1.getTemplateLocation();
        const templatePath = `HYGEN_TMPLS=${templateLocation}`;
        this.log(`Generating new component using template ${template} at ${utils_1.pathWhereScriptIsRunning}/${path}`);
        // Generate template
        child_process_1.execSync(`${templatePath} yarn gen ${template} new ${name} --root=${utils_1.pathWhereScriptIsRunning} --path=${path}`, { cwd: utils_1.rootDirectory, stdio: "inherit" });
    }
}
exports.default = Generate;
Generate.description = "generates new files";
Generate.examples = [
    `$ eb-scripts generate react-component -n MyNewComponent -p src/components
    Loaded templates: _templates
    added: src/MyNewComponent.js
`
];
Generate.flags = {
    help: command_1.flags.help({ char: "h" }),
    // flag with a value (-n, --name=VALUE)
    name: command_1.flags.string({
        char: "n",
        description: "name to print",
        default: exports.DEFAULT_COMPONENT_NAME
    }),
    // flag with a value (-p, --path=VALUE)
    path: command_1.flags.string({
        char: "p",
        description: "path to where you want the files to go"
    })
};
Generate.args = [
    {
        name: "templateName",
        description: "the template you want to use",
        required: true,
        options: templateOptions
    }
];
